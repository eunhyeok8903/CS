
# 데이터베이스  
---

## 데이터베이스 사용 이유  

* DB존재 전에는 파일 시스템 관리  -> 데이터 종속성, 중복성, 무결성 문제 발생

## DB특징  

* 독립성 : DB사이즈 늘리거나 데이터 추가해도 관련 응용프로그램 수정 필요X
* 무결성 : 잘못된 데이터 발생의 경우 유효성 검사를 통해서 무결성 지킴
ex)참조무결성, NULL무결성, KEY무결성 등
* 보안성 : 인가된 사용자만 접근가능
* 일관성 : 하나 변경시 불일치 배제
* 중복성 해결

## 무결성이란?

* 무결성이란 데이터의 정확성, 일관성, 유효성을 유지하는 것, DBMS는 이를 유지하기 위해 다음과같은 무결성을 유지한다.
1. 개체 무결성 : 기본키로 선택된 개체는 빈값을 허용하지 않는다.
2. 참조 무결성 : 참조관계에 있는 두테이블은 항상 일관된 값을 유지한다.
3. 도메인 무결성 : 테이블에 존재하는 필드의 무결성을 유지하기 위해 올바른 데이터값 입력되었는지 확인하는것
4. NULL 무결성 : 특정 속성값에 NULL이 올 수 없다는 조건이 주어진경우 NULL이 입력되었는지 확인하는것
5. 키 무결성 : 한 릴레이션에는 최소한 하나의 키가 존재해야하는 제약조건
6. 고유 무결성 : 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성값은 모두 고유한 값을 가진다. 같으면 안된는 것

## 무결성 유지하려는 이유는?
* 무결성이 유지되어야 잘못된 데이터 발생을 줄이고 실제 값이 일치하는지 신뢰할수 있기 때문이다.

## DB의 성능

* DB의 성능 issue는 디스크 I/O를 어떻게 줄이느냐 문제
* 여기서 디스크 I/O란 디스크 플래터를 통해 읽어야할 데이터에 딛스크 헤더를 가져다 놓고 읽는것
* 즉 랜덤 I/O보다 순차 I/O가 성능 좋을 수 밖에 없다. -> 랜덤 I/O를 줄이는 것이 DB 쿼리 튜닝의 목적이다.

## 인덱스란

* 말그대로 책의 색인과 같다. 책의 내용이 데이터라면 특정 단어의 위치를 알려주는것->인덱스(색인)
* DBMS도 테이블의 모든 데이터 검색해서 원하는 결과 반환하려면 오래걸린다. // KEY,VALUE의 쌍으로 인덱스 저장해 두는것임  
* 인덱스는 항상 정렬된 상태 유지 // 정렬되어있으면 읽기는 쉬우나 삭제,수정시 느림(재정렬 필요하기때문) ->저장성능 희생하고 읽기속도높임
* 사용이유 : 검색의 속도를 높이기 위함

## 인덱스관리
*B+-Tree 인덱스 알고리즘, Hash 인덱스 알고리즘 등

## 트랜젝션
* 작업의 완전성을 보장해주는 것이다.
* 즉, 작업을 완벽하게 처리하지 못한 경우에는 원상태로 복구해서 일부만 적용되는것을 막아주는 기능  

## 트랜젝션의 성질(ACID)  
* Atomicity - 트렌젝션의 연산이 DB에 모두 반영이 되던지 전혀 반영이 안되던지 둘중하나만 수행(원자성)  
* Consistency - 트렌젝션이 성공적으로 완료된 이후에는 언제나 일관성있는 DB상태로 변환되어야함(일관성)  
* Isolation - 수행중인 트랜젝션이 완전히 완료되기 전에는 다른 트랜젝션에서 수행결과를 참조하지 못함(독립성)  
* Durability - 성공적으로 완료된 트렌젝션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다(영속성)  

## 트랜젝션을 병행으로 처리하려할때 발생하는 문제
* 갱신 내용 손실 : 동시에 하나의 데이터가 갱신될 때 하나의 갱신이 누락되는 경우
* 현황 파악 오류 : 하나의 데이터 갱신이 끝나지 않은 시점에서 다른 트랜잭션이 해당 데이터를 조회하는 경우
* 모순성 : 두 트랜잭션이 동시에 실행될 때 데이터베이스가 일관성이 없는 모순된 상태로 남는 문제
* 연쇄 복귀 : 두 트랜잭션이 하나의 레코드를 갱신할 때 하나의 트랜잭션이 롤백하면 다른 하나의 트랜잭션 마저 롤백이 되는 문제

## 트랜젝션을 병행으로 처리했을때 위와 같은 문제 해결방법 - Lock(로킹 제어)
* 트랜젝션의 격리, 동시성 제어 위한 기능
* 동시에 동일한 자원을 요청한 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다. 
* 데드락 발생 가능성 -> 탐지or회피 방법 사용

## 정규화란,목적
* 데이터의 중복을 최소화하고 테이블의 삽입,삭제,갱신 과정에서 발생하는 이상현상을 방지하기 위함이다.

## 각 정규화 단계
* 제 1 정규화 : 각 칼럼들은 값이 원자값을 가지게 바꾼다.
* 제 2 정규화 : 테이블의 모든 컬럼에서 부분 함수적 종속을 제거하는 것
* 제 3 정규화 : 기본키를 제외한 속성들 간의 이행적 함수 종속을 없애는 것
* 제 BCNF화 : 결정자이면서 후보키가 아닌 것들 제거
* 제 4 정규화 : 다치 종속 제거
* 제 5 정규화

## SQL 인젝션
* 해커에 의해 조작된 SQL쿼리문이 DB에 그대로 전달되어 비정상적인 실행을 시키는 공격이다.
* 이를 막기위해서는 입력을 받을 때 특수문자 검사, 에러 발생시 에러 메세지 감추기, 예약어 사용해서
특수문자를 자동으로 이스케이핑 해주는 방법이 있다.

## 관계형 데이터베이스와 비 관계형 데이터베이스의 차이점  

1. 관계형 DB
* 테이블로 이루어져 있으며, 이 테이블은 KEY값과 VALUE의 관계를 나타낸다. 
* 이처럼 데이터의 종속성을 관계로 표현하는것이 관계형 DB의 특징  

2. 비 관계형 DB
* 비 관계형 DB는 행과 열로 이루어진 테이블 형식 스키마를 사용하지 않는 DB이다. 
* 저장되는 데이터 형식의 특정 요구사항에 맞게 최적화된 저장소 모델을 사용하는 것이 특징
* NoSQL(Not Only SQL)이라하며 데이터 저장시 SQL문이 아닌 다른 프로그래밍 언어를 구사한다.

## RDBMS와 비교했을 때 NoSQL의 장점
* 가변적 데이터 구조로 훨씬 유연성이 높다.
* 비정형 데이터를 저장해야할때 가장적합하다.
(mongo는 key값 추가,삭제만 해주면 되었고 JPA를 이용한 MySQL은 어노테이션으로 Entity, 컬럼 다 바꿔주어야했다)

## RDBMS와 비교했을 때 NoSQL의 단점
* 다양하고 복잡한 쿼리가 불가능하고 일관성을 항상 보장할 수 없다는 것

